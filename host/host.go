package host

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"runtime"
	"strings"
)

// findGoTool attempts to locate the go executable. If GOROOT is set, we'll
// prefer the one in there; otherwise, we'll rely on PATH. If the wrapper
// script generated by the gazelle rule is invoked by Bazel, it will set
// GOROOT to the configured SDK. We don't want to rely on the host SDK in
// that situation.
// Copied from https://github.com/bazelbuild/bazel-gazelle/blob/5b8616dbb7dad825c61ffbb12ea9f75622568657/language/go/modules.go#L170
func FindGoTool() string {
	path := "go" // rely on PATH by default
	if goroot, ok := os.LookupEnv("GOROOT"); ok {
		path = filepath.Join(goroot, "bin", "go")
	}
	if runtime.GOOS == "windows" {
		path += ".exe"
	}
	return path
}

func CreateGoMod(ctx context.Context) (alreadyExists bool, err error) {
	currentDir, err := os.Getwd()
	if err != nil {
		return alreadyExists, fmt.Errorf("unable to determine working directory: %w", err)
	}
	goModPath := path.Join(currentDir, "go.mod")
	if _, err = os.Stat(goModPath); !os.IsNotExist(err) { 
		alreadyExists = true
	}
	if !alreadyExists {
		err = GoModInit(ctx, "easteregg")
		if err != nil {
			return alreadyExists, fmt.Errorf("failed to create temporary go.mod: %w", err)
		}
	}
	return alreadyExists, nil
}

func TearDownGoMod(ctx context.Context) error {
	currentDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("unable to determine working directory: %w", err)
	}
	goModPath := path.Join(currentDir, "go.mod")
	goSumPath := path.Join(currentDir, "go.sum")
	err = os.Remove(goModPath)
	if err != nil {
		return fmt.Errorf("failed to delete %s: %w", goModPath, err)
	}
	err = os.Remove(goSumPath)
	if err != nil {
		return fmt.Errorf("failed to delete %s: %w", goSumPath, err)
	}
	return nil
}

func GetCacheDir() (string, error) {
	currentDir, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("unable to determine working directory: %w", err)
	}
	dir := path.Join(currentDir, "tmp")
	if _, err := os.Stat(dir); os.IsNotExist(err) { 
		err = os.MkdirAll(dir, 0700) // Create the cache directory
		if err != nil {
			return "", fmt.Errorf("failed to create directory: %w", err)
		}
	}
	return dir, nil
}

func MustGetCacheDir() string {
	dir, err := GetCacheDir()
	if err != nil {
		panic(err)
	}
	return dir
}

type GoModDownloadResponse struct {
	Path, Version, Info, GoMod, Zip, Dir, Sum, GoModSum string
}

func GoModDownload(ctx context.Context, moduleName string) (*GoModDownloadResponse, error) {
	goTool := FindGoTool()
	dir := MustGetCacheDir()
	env := append(os.Environ(), fmt.Sprintf("GOPATH=%s", dir))

	cmd := exec.CommandContext(ctx, goTool, "mod", "download", "-json", moduleName)
	stderr := &bytes.Buffer{}
	cmd.Stderr = stderr
	cmd.Env = env
	cmd.Dir = dir
	out, err := cmd.Output()
	if err != nil && len(out) == 0 {
		return nil, fmt.Errorf("download command failed: %s: %w", stderr.String(), err)
	}

	type module struct {
		GoModDownloadResponse
		Error string
	}

	mod := new(module)
	err = json.Unmarshal(out, mod)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal output: %w", err)
	}
	if mod.Error != "" {
		// This is a little bit hacky, but if it's failed because we didn't run go get,
		// we just do that here and retry.
		// Download downloads the go module into a temporary directory
		if strings.Contains(mod.Error, "not a known dependency") {
			cmd := exec.CommandContext(ctx, goTool, "get", moduleName)
			cmd.Env = env
			cmd.Dir = dir
			if _, err := cmd.Output(); err != nil {
				return nil, fmt.Errorf("failed to run go get: %w", err)
			}
			return GoModDownload(ctx, moduleName)
		}
	
		return nil, fmt.Errorf("failed to download module: %s", mod.Error)
	}

	return &mod.GoModDownloadResponse, nil
}

func GoModInit(ctx context.Context, name string) error {
	goTool := FindGoTool()
	env := os.Environ()

	cmd := exec.CommandContext(ctx, goTool, "mod", "init", name)
	stderr := &bytes.Buffer{}
	cmd.Stderr = stderr
	cmd.Env = env
	out, err := cmd.Output()
	if err != nil && len(out) == 0 {
		return fmt.Errorf("go mod init command failed: %s: %w", stderr.String(), err)
	}
	return nil
}
